<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/utils/index.js - FAKE DOCUMENTATION</title>
    <meta name="description" content="Fake documentation, intended to be used as demo">
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../assets/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../assets/css/theme.css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,500,600,700' rel='stylesheet' type='text/css'>
    
</head>
<body>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
          <a href="..//index.html" class="navbar-brand">
             <img src="https://camo.githubusercontent.com/891e94cd8dda7f40f451bb27067be513c230318a/68747470733a2f2f7261772e6769746875622e636f6d2f766f6f646f6f74696b69676f642f6c6f676f2e6a732f6d61737465722f626f676a732f6a732e706e67" alt="enterprise logo">
            <span>FAKE DOCUMENTATION</span>
          </a>
        </div>

        <div class="collapse navbar-collapse" id="nav">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/KristenGarnier/yuidoc-ember-blue-theme" class="fa fa-github github"></a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div id="main-wrapper" class="row">
        <div id="content-wrapper">
            <ol class="panel-group" id="sidebar" role="tablist" aria-multiselectable="true">
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-search-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-search" aria-expanded="true" aria-controls="collapseOne">
                        Search
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-search" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-search-heading">
                        <div class="panel-body">
                            <div id="api-tabview-filter">
                                <input type="search" id="api-filter" placeholder="Search...">
                            </div>
                        </div>
                    </div>
                </li>
                    <li class="panel panel-default">
                        <div class="panel-heading" role="tab" id="sidebar-version-heading">
                            <h4 class="panel-title">
                                <a role="button" href="https://github.com/KristenGarnier/yuidoc-ember-blue-theme/commits/0" target="_blank">
                                  Tag: 1.0.0
                                </a>
                            </h4>
                        </div>
                    </li>
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-modules-heading">
                        <h4 class="panel-title">
                    <a role="button" data-toggle="collapse" href="#sidebar-modules" aria-expanded="true" aria-controls="collapseOne">
                      Modules
                    </a>
                  </h4>
                    </div>
                    <div id="sidebar-modules" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-modules-heading">
                        <div class="panel-body">
                                <ol>
                                        <li>
                                            <a href="../modules/Base.html">Base</a>
                                        </li>
                                        <li>
                                            <a href="../modules/Config.html">Config</a>
                                        </li>
                                        <li>
                                            <a href="../modules/domListenerCallback.html">domListenerCallback</a>
                                        </li>
                                        <li>
                                            <a href="../modules/Template.html">Template</a>
                                        </li>
                                        <li>
                                            <a href="../modules/Utils.html">Utils</a>
                                        </li>
                                </ol>
                        </div>
                    </div>
                </li>
            
                <li class="panel panel-default">
                    <div class="panel-heading" role="tab" id="sidebar-classes-heading">
                        <h4 class="panel-title">
                      <a role="button" data-toggle="collapse" href="#sidebar-classes" aria-expanded="true" aria-controls="collapseOne">
                        Classes
                      </a>
                    </h4>
                    </div>
                    <div id="sidebar-classes" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="sidebar-classes-heading">
                        <div class="panel-body">
                            <ol>
                                    <li>
                                        <a href="../classes/__.html">__</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Base.html">Base</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Cache.html">Cache</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Config.html">Config</a>
                                    </li>
                                    <li>
                                        <a href="../classes/diffDays.html">diffDays</a>
                                    </li>
                                    <li>
                                        <a href="../classes/domListenerCallback.html">domListenerCallback</a>
                                    </li>
                                    <li>
                                        <a href="../classes/ifEqual.html">ifEqual</a>
                                    </li>
                                    <li>
                                        <a href="../classes/momentify.html">momentify</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Renders.html">Renders</a>
                                    </li>
                                    <li>
                                        <a href="../classes/Ternary.html">Ternary</a>
                                    </li>
                                    <li>
                                        <a href="../classes/undoTraduction.html">undoTraduction</a>
                                    </li>
                                    <li>
                                        <a href="../classes/UtilisClass.html">UtilisClass</a>
                                    </li>
                            </ol>
                        </div>
                    </div>
                </li>
            </ol>
            <div class="content-container">
                <div class="apidocs">
                    <div id="docs-main">
                        <div class="content">
<div class="page-header">
    <h1><i class="fa fa-file-code-o" aria-hidden="true"></i> src/utils/index.js File</h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
import curry from &#x27;curry&#x27;
import moment from &#x27;moment&#x27;
import compose from &#x27;compose-function&#x27;
import base64 from &#x27;base-64&#x27;
import axios from &#x27;axios&#x27;
import config, {whiteListCategories} from &#x27;../config&#x27;
import i18n from &#x27;i18next&#x27;

/* eslint no-console: &quot;off&quot; */

/**
 * Ensemble de classe utilitaires
 *
 * @module Utils
 * @class UtilisClass
 *
 * @since 0.1.0
 */

/**
 * Objet contenant des méthodes pour bind et unbind des évènement sur un node List
 * @type {{bind: ((nodeList?, event?, callback?)), unbind: ((nodeList?, event?, callback?))}}
 *
 * @since 0.1.0
 */
export const manageEvents = {
    bind(nodeList, event, callback) {
        Array.from(nodeList).forEach((node) =&gt; node.addEventListener(event, callback))
    },
    unbind(nodeList, event, callback){
        Array.from(nodeList).forEach((node) =&gt; node.removeEventListener(event, callback))
    }
}

/**
 * Méthode pour du curry de paramètres ( Non ce n&#x27;est pas un plat )
 *
 * Un peu de documentation pour le [curry](https://www.sitepoint.com/currying-in-functional-javascript/)
 *
 * @method curryCb
 * @param {function} cb
 *
 * @since 0.1.0
 */
export const curryCb = (cb) =&gt; {
    return curry(cb)
}

/**
 * Méthode pour encoder en base 64 des chaines de catactères ou des objets / tableaux
 *
 * @method base64Encode
 * @param {*} toEncode
 * @returns {string}
 *
 * @since 0.2.0
 */
export const base64Encode = (toEncode) =&gt; {
    if (Array.isArray(toEncode) || typeof toEncode === &#x27;object&#x27;) {
        return base64.encode(JSON.stringify(toEncode))
    }

    return base64.encode(toEncode)
}

/**
 * Méthode permettant de construire dune requête fetch
 *
 * @method constructRequest
 * @param {string} uri Uri du service web
 * @param {string} endpoint Endpoint sur lequel récupérer les données
 * @param {string} query la query associée ( Optionnel )
 * @param {object} options Options de cofiguration pour la requete ( Optionnel )
 * @returns {Promise.&lt;T&gt;}
 *
 * @since 0.2.0
 */
export const constructRequest = (uri, endpoint, query = null, options = {mode: &#x27;no-cors&#x27;}) =&gt; {
    const url = query ? &#x60;${uri}${endpoint}?q=${query}&amp;lang=${config.language}&#x60; : &#x60;${uri}${endpoint}?lang=${config.language}&#x60;

    if (process.env.NODE_ENV !== &#x27;test&#x27;) {
        makeItSpin(true)
    }

    return axios(url, options)
        .catch((err) =&gt; {
            makeItSpin(false)
            throw new Error(err)
        })
}

/**
 * Récupères les paramètres inscrit dans le moteur de recherche
 *
 * @method getParametersSearchEngine
 * @return {{start: moment, end: moment, type: string, person: int}}
 */
export function getParametersSearchEngine() {
    return {
        start: moment(document.querySelector(&#x60;input[name=&quot;${config.form.start}&quot;]&#x60;).value, &#x27;D/M/Y&#x27;).format(&#x27;DD/MM/Y&#x27;),
        end: moment(document.querySelector(&#x60;input[name=&quot;${config.form.end}&quot;]&#x60;).value, &#x27;D/M/Y&#x27;).format(&#x27;DD/MM/Y&#x27;),
        type: document.querySelector(&#x60;select[name=&quot;${config.form.type}&quot;]&#x60;).value,
        person: document.querySelector(&#x60;select[name=&quot;${config.form.person}&quot;]&#x60;).value
    }
}

/**
 * Log les performances de l&#x27;application dans le back end
 * Attention, écoute un évènement pour avoir les derniers critères et finaliser l&#x27;envoi du log
 *
 * @method logPerformance
 * @param {string} type Type du log
 * @param {string} ip Ip du client
 * @param {int} time Nombre de secondes écoulées
 * @return {function}
 */
export function logPerformance(type, ip, time) {
    let asked = true
    if (window.hasOwnProperty(&#x27;eventManager&#x27;)) {
        window.eventManager.on(&#x27;LOG_RESULT&#x27;, (nbResults) =&gt; {
            if(asked) {
                asked = false
                const params = new URLSearchParams()
                params.append(&#x27;type_log&#x27;, type)
                params.append(&#x27;params_log&#x27;, JSON.stringify({
                    ip,
                    time,
                    criteria: getParametersSearchEngine(),
                    nb_results: nbResults
                }))

                logToBackend(params)
            }
        })
    }
}

/**
 * Envoie la recherche au backend en cas de non résultat
 *
 * @method logNoResults
 * @param {string} type type du log
 * @param {array} search Tableau du state des recherches
 */
export function logNoResults(type, search) {

    const params = new URLSearchParams()
    params.append(&#x27;type_log&#x27;, type)
    params.append(&#x27;params_log&#x27;, JSON.stringify({
        search
    }))

    logToBackend(params)
}

/**
 * Méthode permettant de logger dans la base de donnée
 * Bien penser que le paramètre à passer est de type URLSearchParams --&gt; sinon ne marche pas
 *
 * @method logToBackend
 * @param {object} params Objet de type UrlSearchParams
 */
export function logToBackend(params) {

    axios.post(&#x27;/wp-json/iris-logger/v1/logs&#x27;, params)
        .catch((err) =&gt; {
            throw new Error(err)
        })
}

/**
 * Gestion du spinner
 *
 * @method makeItSpin
 * @param {boolean} shouldItSpin Si le spinner doit être affiché ou enlevé
 *
 * @since 1.2.0
 */
export function makeItSpin(shouldItSpin) {

    if (document.querySelector(&#x27;.spinner-wrapper:not(.iframe)&#x27;)) {
        if (shouldItSpin) {
            document.querySelector(&#x27;.spinner-wrapper:not(.iframe)&#x27;).style.display = &#x27;block&#x27;
        } else {
            document.querySelector(&#x27;.spinner-wrapper:not(.iframe)&#x27;).style.display = &#x27;none&#x27;
        }
    }
}

/**
 * Méthode permettant de savoir si la date à un intervalle plus grand que la limite en minute renseignée
 *
 * @method isTimeSmallerThan
 * @param {string} entry Date d&#x27;entrée
 * @param {int} limit Limite en temps depuis maintenant ( en minute )
 * @returns {boolean}
 *
 * @since 0.2.0
 */
export const isTimeSmallerThan = (entry, limit) =&gt; {
    const last = moment(entry)
    const diff = moment.utc(moment().diff(last)).valueOf()

    return ((diff / 1000) / 60) &lt; limit
}


/**
 * Méthod permettant d&#x27;itérer à travers tous les terms du state
 *
 * @method termsIteration
 * @param {func} cb
 * @param {object} state
 * @returns {Array}
 *
 * @since 0.2.0
 */
export function termsIteration(cb, state) {
    return state.map((proposal) =&gt; {
        return Object.assign(proposal, {
            accomodations: proposal.accomodations.map((accomodation) =&gt; {
                return Object.assign(accomodation, {
                    post: Object.assign(accomodation.post, {
                        terms: accomodation.post.terms.map(cb)
                    })
                })
            })
        })
    })
}

/**
 * Méthode permettant d&#x27;isoler tous les termes de l&#x27;objet envoyé
 *
 * @method getAllTerms
 * @param {Array} array
 *
 * @since 0.2.0
 */
export function getAllTerms(array) {

    let newTerms = []

    array.map((item) =&gt; {
        return item.terms
    }).forEach((t) =&gt; {
        if (Array.isArray(t)) {
            newTerms = [
                ...newTerms,
                ...t
            ]
        } else {
            newTerms = [
                ...newTerms,
                t
            ]
        }

    })

    return newTerms
}

/**
 * Méthode permetant de créer les objets de taxonomies
 *
 * @method  createTaxonomies
 * @param {Array} array
 *
 * @since 0.2.0
 */
export function createTaxonomies(array) {
    const ret = array.reduce((previous, current) =&gt; {

        const newTax = {
            name: current.taxonomy,
            nameAlias: config.aliases.hasOwnProperty(current.taxonomy) ? i18n.t(config.aliases[current.taxonomy]) : current.taxonomy,
            terms: [
                current
            ]
        }

        if (previous.length === 0) {
            return [
                ...previous,
                newTax
            ]
        }

        let elem = false

        const taxs = previous.map((tax) =&gt; {
            let verificator = false
            if (tax.name === newTax.name) {
                elem = true
                tax.terms.map((term) =&gt; {
                    if (term.term_id === current.term_id) {
                        verificator = true
                    }
                })
                if (!verificator) {
                    return Object.assign({}, tax, {
                        terms: [
                            ...tax.terms,
                            current
                        ]
                    })
                }

            }
            return tax
        })

        if (!elem) {
            return [
                ...taxs,
                newTax
            ]
        }
        return taxs

    }, [])


    return ret
}

/**
 * Méthode permettant de récupérer tous les posts dans le state
 *
 * @methode getAllPosts
 * @param {Array} array
 * @returns {Array}
 *
 * @since 0.2.0
 */
export function getAllPosts(array) {
    const ret = array.map((proposal) =&gt; proposal.accomodations.map((accomodation) =&gt; accomodation.post))
    return ret
}

/**
 * Méthode permettant de réduire de un niveau des tableaux nestled
 *
 * @method flatten
 * @param {Array} arrays
 * @returns {Array}
 *
 * @since 0.2.0
 */
export function flatten(...arrays) {
    const ret = [].concat.apply([],
        [].concat.apply([], arrays)
    )
    return ret
}

/**
 * Méthode permettant de filtrer les proposals, selon les values de search values
 *
 * La méthode vient filtrer tous les posts, ayant les terms cochés dans le formulaire de recherche
 * Cette relation est de type AND, et non OR
 *
 *
 * La relation de type AND est réalisé au niveau du filtre sur les valeurs de recheche,
 * en effet, si le filtre sur les searchValues n&#x27;est pas de la même longeur que searchValues,
 * cela veut dire que tous les termes ne sont pas présents dans ce post. Ce post n&#x27;est donc pas pris en compte par le filtre.
 *
 * @method filterProposalWithSearchValues
 * @param {array} data Tableau des valeurs du state
 * @param {array} searchValues Tableau des valeurs cochées
 * @returns {Array}
 */
export function filterProposalWithSearchValues(searchValues, data) {

    const gammesIds = searchValues.gammes.map((gamme) =&gt; {
        return gamme.term_id
    })

    const ordinarysIds = searchValues.ordinarys.map((o) =&gt; {
        return o.term_id
    })

    return data.filter((proposal) =&gt; {
        return proposal.accomodations.filter((accomodation) =&gt; {

                let gammes,
                    ordinarys

                if (gammesIds.length &gt; 0) {
                    gammes = accomodation.post.terms.filter((term) =&gt; gammesIds.includes(term.term_id))
                }

                if (ordinarysIds.length &gt; 0 &amp;&amp; gammes !== undefined &amp;&amp; gammes.length &gt; 0) {
                    ordinarys = accomodation.post.terms.filter((term) =&gt; ordinarysIds.includes(term.term_id))
                }

                if (gammes === undefined) {
                    return false
                }

                return ordinarys !== undefined &amp;&amp; ordinarys.length === ordinarysIds.length &amp;&amp; gammes !== undefined ||
                    gammes !== undefined &amp;&amp; ordinarys === undefined &amp;&amp; gammes.length &gt; 0

            }).length &gt; 0
    })
}

/**
 * Méthode permettant de filtrer les proposals, selon les values de search values
 *
 * La méthode vient filtrer tous les posts, ayant les terms cochés dans le formulaire de recherche
 * Cette relation est de type AND, et non OR
 *
 *
 * La relation de type AND est réalisé au niveau du filtre sur les valeurs de recheche,
 * en effet, si le filtre sur les searchValues n&#x27;est pas de la même longeur que searchValues,
 * cela veut dire que tous les termes ne sont pas présents dans ce post. Ce post n&#x27;est donc pas pris en compte par le filtre.
 *
 * @method filterPostWithSearchValues
 * @param {array} data Tableau des valeurs du state
 * @param {array} searchValues Tableau des valeurs cochées
 * @returns {Array}
 */
export function filterPostWithSearchValues(searchValues, data) {

    const gammesIds = searchValues.gammes.map((gamme) =&gt; {
        return gamme.term_id
    })

    const ordinarysIds = searchValues.ordinarys.map((o) =&gt; {
        return o.term_id
    })

    const test = data.filter((post) =&gt; {
        let gammes,
            ordinarys

        if (gammesIds.length &gt; 0) {
            gammes = post.terms.filter((term) =&gt; gammesIds.includes(term.term_id))
        }

        if (ordinarysIds.length &gt; 0 &amp;&amp; gammes !== undefined &amp;&amp; gammes.length &gt; 0) {
            ordinarys = post.terms.filter((term) =&gt; ordinarysIds.includes(term.term_id))
        }

        if (gammes === undefined) {
            return false
        }

        return ordinarys !== undefined &amp;&amp; ordinarys.length === ordinarysIds.length &amp;&amp; gammes !== undefined ||
            gammes !== undefined &amp;&amp; ordinarys === undefined &amp;&amp; gammes.length &gt; 0
    })

    return test
}

/**
 * Méthode retournant tous les termes dont le state est à true
 *
 * Cette méthode filtre les objet n&#x27;ayant pas un state à true
 *
 * @method filterTermsByState
 * @param {Array} array
 * @returns {Array}
 *
 * @since 0.2.0
 */
export function filterTermsByState(array) {
    return array.reduce((previous, current) =&gt; {
        return [
            ...previous,
            ...current.terms.filter((term) =&gt; {
                return term.state !== false
            })
        ]
    }, [])
}

/**
 * Méthode permettant de regrouper les proposition par gamme d&#x27;hébergement
 *
 * @method regroupProposalsByCategories
 * @param array
 * @returns {array}
 *
 * @since 0.3.0
 */
export function regroupProposalsByCategorie(array) {

    if (array[0] !== undefined &amp;&amp; array[0].hasOwnProperty(&#x27;is_mono_accomodation&#x27;) &amp;&amp; array[0].is_mono_accomodation !== true) {
        return [
            {
                name: false,
                proposals: [
                    ...array
                ]
            }
        ]
    }


    return array.reduce((previous, current) =&gt; {

        const newCategorie =
            Object.assign({},
                ...current.accomodations.map((accomodation) =&gt; {
                    return accomodation.post.terms.filter((term) =&gt; {
                        return term.taxonomy === &quot;accomodation-range&quot;
                    })
                })[0],
                {
                    proposals: [
                        current
                    ]
                })

        if (previous.length === 0) {
            return [
                ...previous,
                newCategorie
            ]
        }

        let elem = false

        const categories = previous.map((categorie) =&gt; {
            if (categorie.term_id === newCategorie.term_id) {
                elem = true
                return Object.assign({}, categorie, {
                    proposals: [
                        ...categorie.proposals,
                        current
                    ]
                })

            }
            return categorie
        })

        if (!elem) {
            return [
                ...categories,
                newCategorie
            ]
        }
        return categories

    }, [])

}

/**
 * Méthode utilitaire permettant de taiter les posts pour le render
 *
 * @method propsalData
 * @param {array} data
 * @returns {array}
 *
 * @since 0.3.0
 */
export function proposalData(data) {
    return compose(
        reorderProposals,
        regroupProposalsByCategorie,
        curryCb(filterProposalWithSearchValues)(filteredTerms(data))
    )(data)
}

/**
 * Méthode utilitaire permettant de savoir si toutes les propositions envoyées sont des contres proposition ou non
 *
 * @method hasProposalsCounter
 * @param {array} proposals
 * @returns {boolean}
 *
 * @since 2.2.0
 */
export function hasProposalsCounter(proposals) {
    return proposals.reduce((previous, current) =&gt; {
            return previous += current.proposals.filter((prop) =&gt; prop.is_counter_proposal).length
        }, 0) &gt; 0
}

/**
 * Méthode utilitaire permettant d&#x27;extraire un objet pour le search form
 *
 * @method searchFromData
 * @param {array} data
 * @returns {array}
 *
 * @since 0.3.0
 */
export function searchFormData(data) {
    return compose(
        curryCb(filterOutCategories)(whiteListCategories),
        setTypeValue,
        curryCb(disableItems)(
            compose(
                getSelectedTermsId,
                getAllTerms,
                curryCb(filterPostWithSearchValues)(filteredTerms(data)),
                flatten,
                getAllPosts,
            )(data)
        ),
        reorderTerms,
        createTaxonomies,
        getAllTerms,
        flatten,
        getAllPosts,
    )(data)
}

/**
 * Méthode privée permettant d&#x27;isoler tous les terms cochés
 */
const filteredTerms = compose(
    categoriseFilteredTerms,
    filterTermsByState,
    createTaxonomies,
    getAllTerms,
    flatten,
    getAllPosts,
)

export function categoriseFilteredTerms(data) {
    return data.reduce((previous, term) =&gt; {
            if (term.taxonomy.includes(&#x27;range&#x27;)) {
                return Object.assign({}, previous, {
                    gammes: [
                        ...previous.gammes,
                        term
                    ]
                })
            }

            return Object.assign({}, previous, {
                ordinarys: [
                    ...previous.ordinarys,
                    term
                ]
            })
        },
        {
            gammes: [],
            ordinarys: []
        }
    )
}

/**
 * Méthode permettant de filtrer les posts ne comportant pas de posts
 *
 * @method filterNoGood
 * @param {Array} data
 * @returns {Array}
 *
 * @since 1.2.0
 */
export function filterNoGood(data) {
    return data.filter((d) =&gt; {
        return d.accomodations.filter((accomodation) =&gt; {
                return accomodation.hasOwnProperty(&#x27;post&#x27;)
            }).length === d.accomodations.length
    })
}

/**
 * Fonction pour parser le json dans les objets
 *
 * @method parseJson
 * @param {Array} state
 * @returns {Array}
 *
 * @since 1.2.0
 */
export function parseJson(state) {
    return state.map((proposal) =&gt; {
        return Object.assign(proposal, {
            accomodations: proposal.accomodations.map((accomodation) =&gt; {
                return Object.assign(accomodation, {
                    post: Object.assign(accomodation.post, {
                        postmetas: parsePostMetas(accomodation.post.postmetas),
                        terms: accomodation.post.terms.map((term) =&gt; {
                            return Object.assign(term, {
                                termmetas: parseTermMetas(term.termmetas)
                            })
                        })
                    })
                })
            })
        })
    })
}


/**
 * Parse les termmetas en fonction de ce qui existe dans l&#x27;objet
 *
 * @method parseTermMetas
 * @param {object} obj
 * @returns {object}
 *
 * @since 1.2.0
 */
function parseTermMetas(obj) {
    if (obj.hasOwnProperty(&#x27;accomodation_range_gallery&#x27;) &amp;&amp; obj.hasOwnProperty(&#x27;accomodation_range_forwarded_picture&#x27;)) {
        return Object.assign(obj, {
            accomodation_range_gallery: JSON.parse(obj.accomodation_range_gallery),
            accomodation_range_forwarded_picture: JSON.parse(obj.accomodation_range_forwarded_picture)
        })
    } else if (obj.hasOwnProperty(&#x27;accomodation_range_gallery&#x27;)) {
        return Object.assign(obj, {
            accomodation_range_gallery: JSON.parse(obj.accomodation_range_gallery),
        })
    } else {
        return obj
    }
}

/**
 * Parse dans les post metas en fonctioon de ce qui existe
 *
 * @method parsePostMetas
 * @param {object} obj
 * @returns {object}
 *
 * @since 1.2.0
 */
function parsePostMetas(obj) {
    if (obj.hasOwnProperty(&#x27;accomodation_gallery&#x27;) &amp;&amp; obj.accomodation_gallery !== &#x27;&#x27;) {
        return Object.assign(obj, {
            accomodation_gallery: JSON.parse(obj.accomodation_gallery),
        })
    } else {
        return obj
    }
}

/**
 * Reorder the terms according to the order position
 *
 * @method reorderTerms
 * @param {Array} data
 * @returns {Array}
 *
 * @since 1.2.0
 */
export function reorderTerms(data) {
    return data.map((category) =&gt; {
        return Object.assign(category, {
            terms: category.name === &#x27;accomodation-room&#x27; ? category.terms.sort(sortByName) : category.terms.sort(sortByTermMeta)
        })
    })
}

/**
 * Compare two object by termMeta and send back the result
 *
 * @method sortbyTermMeta
 * @param {Object} a
 * @param {Object} b
 * @returns {number}
 *
 * @since 2.0.0
 */
export function sortByTermMeta(a, b) {
    const property = &#x60;${a.taxonomy}_order&#x60;.replace(&#x27;-&#x27;, &#x27;_&#x27;)

    if (a.termmetas.hasOwnProperty(property)) {
        return a.termmetas[property] - b.termmetas[property]
    } else {
        return -1
    }
}

/**
 * Compare two object by name and send back the result
 *
 * @method sortbyName
 * @param {Object} a
 * @param {Object} b
 * @returns {number}
 *
 * @since 2.1.0
 */
export function sortByName(a, b) {
    return Number(a.name) - Number(b.name)
}

/**
 * Reorder proposals by the order given
 *
 * @method reorderProposals
 * @param {array} data
 * @returns {Array}
 *
 * @since 2.0.0
 */
export function reorderProposals(data) {
    return data.sort(sortByTermMeta)
}

/**
 * Met en disable les items qui ne sont pas sélectionnable
 *
 * @method disableItems
 * @param {object} selectedValuesIds
 * @param {Array} data
 * @returns {Array}
 */
export function disableItems(selectedValuesIds, data) {
    if (selectedValuesIds.ordinarys.length &gt; 0 || selectedValuesIds.gammes.length &gt; 0) {
        return data.map((category) =&gt; {
            return Object.assign(category, {
                terms: category.terms.map((term) =&gt; {

                    if (term.taxonomy.includes(&#x27;range&#x27;) &amp;&amp; !term.state) {
                        return Object.assign({}, term, {
                            disable: false
                        })
                    }

                    if (!selectedValuesIds.ordinarys.includes(term.term_id) &amp;&amp; !selectedValuesIds.gammes.includes(term.term_id)) {
                        return Object.assign({}, term, {
                            disable: true
                        })
                    }

                    return term

                })
            })
        })
    }

    return data
}


/**
 * Récupération de tous les terms id sélectionnés
 *
 * @method getSelectedTermsId
 * @param {Array} selectedTerms
 * @returns {Array}
 *
 * @since 1.2.0
 */
export function getSelectedTermsId(selectedTerms) {
    return selectedTerms.reduce((previous, selected) =&gt; {

        if (selected.taxonomy.includes(&#x27;range&#x27;)) {
            if (!previous.gammes.includes(selected.term_id)) {
                return Object.assign({}, previous, {
                    gammes: [
                        ...previous.gammes,
                        selected.term_id
                    ]
                })
            }
        }

        if (!previous.ordinarys.includes(selected.term_id)) {
            return Object.assign({}, previous, {
                ordinarys: [
                    ...previous.ordinarys,
                    selected.term_id
                ]
            })
        }

        return previous

    }, {
        gammes: [],
        ordinarys: []
    })
}

/**
 * Met la valeur contenue dans le localhost pour le type d&#x27;hébergement [location, emplacement,etc]
 *
 * @method setTypeValue
 * @param {array} data
 * @returns {array}
 *
 * @since 2.0.0
 */
export function setTypeValue(data) {
    if (process.env.NODE_ENV === &#x27;test&#x27;) {
        return data
    }

    return data.map((category) =&gt; {
        return Object.assign(category, {
            terms: category.terms.map((term) =&gt; {
                if (localStorage.getItem(&#x27;dates&#x27;)) {
                    if (term.slug === JSON.parse(localStorage.getItem(&#x27;dates&#x27;)).type.toLowerCase() &amp;&amp; isTimeSmallerThan(JSON.parse(localStorage.getItem(&#x27;dates:timestamp&#x27;)), config.limit)) {
                        return Object.assign(term, {
                            state: true
                        })
                    }
                }

                if (config.hasOwnProperty(&#x27;form&#x27;) &amp;&amp; config.form.hasOwnProperty(&#x27;default_type&#x27;)) {
                    if (term.slug === config.form.default_type.toLowerCase()) {
                        return Object.assign(term, {
                            state: true
                        })
                    }
                }
                return term
            })
        })
    })
}

/**
 * Met toutes les gammes à true
 *
 * @method allGammesToTrue
 * @param {array} data
 * @returns {array}
 *
 * @since 2.0.0
 */
export function allGammesToTrue(data) {
    return data.map((proposal) =&gt; {
        return Object.assign(proposal, {
            accomodations: proposal.accomodations.map((accomodation) =&gt; {
                return Object.assign(accomodation, {
                    post: Object.assign(accomodation.post, {
                        terms: accomodation.post.terms.map((term) =&gt; {
                            if (term.taxonomy.includes(&#x27;range&#x27;)) {
                                return Object.assign(term, {
                                    state: true
                                })
                            }
                            return term
                        })
                    })
                })
            })
        })
    })
}

/**
 * Filtre la propriété langage du formulaire
 *
 * Depecated since filterOutCategories exists
 *
 * @method filterLanguageOut
 * @param {array} data
 * @returns {array}
 *
 * @since 2.0.0
 */
export function filterLanguageOut(data) {
    console.info(&#x27;-- filterLanguageOut is deprecated, prefer filterOutCategories&#x27;)
    return data.filter((category) =&gt; category.name.toLowerCase() !== &#x27;language&#x27;)
}

/**
 * Filtre les catégories non présente dans la white list
 *
 * @method filterOutCategories
 * @param {array} data
 * @param {array} whiteList
 * @returns {array}
 *
 * @since 2.0.0
 */
export function filterOutCategories(whiteList, data) {
    return data.filter((category) =&gt; whiteList.includes(category.name.toLowerCase()))
}

/**
 * Filtre les propositions qui sont des counter proposals
 *
 * @method filterOutCounter
 * @param {array} proposals
 * @returns {array}
 *
 * @since 2.2.0
 */
export function filterOutCounter(proposals) {
    return proposals.map((proposal) =&gt; {
        return Object.assign({}, proposal, {
            proposals: proposal.proposals.filter((prop) =&gt; !prop.is_counter_proposal)
        })
    })
        .filter((proposal) =&gt; proposal.proposals.length &gt; 0 )
}

/**
 * Filtre les propositions qui ne sont pas des counter proposals
 *
 * @method filterOutNotCounter
 * @param {array} proposals
 * @returns {array}
 *
 * @since 2.2.0
 */
export function filterOutNotCounter(proposals) {
    return proposals.map((proposal) =&gt; {
        return Object.assign({}, proposal, {
            proposals: proposal.proposals.filter((prop) =&gt; prop.is_counter_proposal)
        })
    })
        .filter((proposal) =&gt; proposal.proposals.length &gt; 0 )
}

export default {
    base64Encode,
    manageEvents,
    curryCb,
    constructRequest,
    isTimeSmallerThan,
    termsIteration,
    getAllTerms,
    createTaxonomies,
    getAllPosts,
    flatten,
    filterProposalWithSearchValues,
    filterPostWithSearchValues,
    filterTermsByState,
    regroupProposalsByCategorie,
    proposalData,
    searchFormData,
    filterNoGood,
    parseJson,
    reorderTerms,
    disableItems,
    getSelectedTermsId,
    setTypeValue,
    reorderProposals,
    hasProposalsCounter
}

    </pre>
</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/vendor/jquery/jquery.min.js"></script>
    <script src="../assets/vendor/jquery-ui/jquery-ui.min.js"></script>
    <script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
    <script src="../assets/vendor/github-slugger/slugger.js"></script>
    <script src="../assets/js/yuidoc-bootstrap.js"></script>
</body>
</html>
